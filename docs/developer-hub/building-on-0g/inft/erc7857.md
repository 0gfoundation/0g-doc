---
id: erc7857
title: ERC-7857 Standard
sidebar_position: 2
description: Technical details of the ERC-7857 standard for Intelligent NFTs
keywords: [ERC-7857, INFT, standard, specification, transfer mechanism]
---

# ERC-7857: A Standard Designed for AI Agents

ERC-7857 is a new NFT standard introduced by 0G Labs, specifically designed to address the limitations of traditional NFT standards when applied to AI agents. It enables the creation, ownership, and secure transfer of INFTs with their complete intelligence intact.

## Key Features & Advantages

- **Privacy-Preserving Metadata:** Allows sensitive metadata (the agent's "intelligence") to be encrypted and kept private, protecting proprietary information.
- **Secure Metadata Transfers:** Ensures that when an INFT is transferred, both the ownership and the encrypted metadata are securely passed to the new owner in a verifiable way.
- **Dynamic Data Management:** Supports the dynamic nature of AI agents, allowing their metadata (state, models, behaviors) to be updated securely within the NFT framework.
- **Decentralized Storage Integration:** Works with systems like 0G Storage for secure, permanent, and tamper-proof storage and access management of metadata.
- **Verifiable Ownership & Control:** Uses cryptographic proofs and oracles to validate metadata transfers, ensuring integrity.
- **AI-Specific Functionality:** Built for AI use cases, enabling features like agent lifecycle management and ownership verification before task execution.

## How ERC-7857 Works

The transfer mechanism in ERC-7857 is designed to ensure that both token ownership and access to the token's encrypted metadata are securely transferred. This process involves several key components:

### Core Process Flow

1. **Encryption & Commitment:** The AI agent's metadata is encrypted. A hash (commitment) of this encrypted data is created as proof of authenticity without revealing the content.
2. **Secure Transfer Initiation:** When the INFT is transferred, a trusted oracle (potentially using secure environments like TEEs) decrypts the original metadata.
3. **Re-encryption for Receiver:** The oracle generates a new encryption key, re-encrypts the metadata with it, and stores this new encrypted metadata (e.g., on 0G Storage).
4. **Key Delivery:** The new encryption key is encrypted using the receiver's public key. This ensures only the intended new owner can access the actual metadata key.
5. **Verification & Finalization:** The transfer function on the smart contract verifies proofs: the sender's access, the oracle's validation that the new metadata matches the old, and the receiver's signed acknowledgment. If valid, the NFT ownership transfers, and the receiver gets the encrypted metadata key.
6. **Access Granted:** The receiver uses their private key to decrypt the metadata key, granting them full access to the agent's encrypted intelligence.

<div style={{textAlign: 'center'}}>
  <img src="/img/ERC7857-flow.webp" alt="ERC7857 Flow" style={{maxWidth: '100%'}} />
</div>

## Oracle Implementations

ERC-7857 supports two primary oracle implementations:

### TEE (Trusted Execution Environment)

In the TEE implementation:
- The sender transmits the encrypted data and key to the TEE
- The TEE securely decrypts the data, generates a new key, and re-encrypts the metadata
- The TEE encrypts the new key with the receiver's public key
- The TEE outputs the sealed key and corresponding hash values
- This approach offers strong security as the TEE can generate its own secure keys

<div style={{textAlign: 'center'}}>
  <img src="/img/ERC7857-Tee-imp.webp" alt="TEE Flow" style={{maxWidth: '100%'}} />
</div>

### ZKP (Zero-Knowledge Proof)

In the ZKP implementation:
- The sender provides both old and new keys to the ZKP system
- The ZKP verifies that the metadata was correctly re-encrypted
- Unlike TEE, ZKP cannot independently generate new keys
- Receivers should change keys after transfer for enhanced security

<div style={{textAlign: 'center'}}>
  <img src="/img/ERC7857-Zk-imp.webp" alt="ZKP Flow" style={{maxWidth: '100%'}} />
</div>

## Standard Interface Functions

ERC-7857 extends the standard ERC-721 interface with additional functions specifically designed for INFTs:

```solidity
// Core transfer function for both token and metadata
function transfer(
    address to,
    uint256 tokenId,
    bytes calldata proof
) external;

// Create a clone with the same metadata
function clone(
    address to,
    uint256 tokenId,
    bytes calldata proof
) external returns (uint256 newTokenId);

// Authorize usage without transferring ownership
function authorizeUsage(
    address to,
    uint256 tokenId,
    bytes calldata proof,
    uint256 expiry
) external;

// Update token metadata
function updateMetadata(
    uint256 tokenId,
    bytes32 newMetadataRoot,
    bytes calldata proof
) external;

// Verify if an address is authorized to use a token
function isAuthorized(
    address user,
    uint256 tokenId
) external view returns (bool, uint256);
```

### Additional Functions

ERC-7857 also supports:

- **clone():** Similar to transfer() but creates a new token with the same metadata instead of changing ownership of the original token.
- **authorizeUsage():** Adds authority for using the token's private metadata without granting access to the raw data, requiring a sealed executor that processes the metadata securely.
- **updateMetadata():** Allows the owner to update the AI agent's metadata as it evolves or learns, using a secure verification process.

## Events

The standard defines several events to track INFT lifecycle:

```solidity
// Emitted when metadata is updated
event MetadataUpdated(
    uint256 indexed tokenId,
    bytes32 oldMetadataRoot,
    bytes32 newMetadataRoot
);

// Emitted when usage is authorized
event UsageAuthorized(
    uint256 indexed tokenId,
    address indexed owner,
    address indexed user,
    uint256 expiry
);

// Emitted when a token is cloned
event TokenCloned(
    uint256 indexed originalTokenId,
    uint256 indexed newTokenId,
    address indexed owner
);
```

## Metadata Structure

The standard recommends a flexible metadata structure that can accommodate different AI agent types:

```json
{
  "name": "AI Agent Name",
  "description": "Description of the agent's capabilities",
  "model": {
    "type": "model_type",
    "version": "1.0",
    "weights": "encrypted_weights_data_reference",
    "architecture": "model_architecture_specification"
  },
  "parameters": {
    "param1": "value1",
    "param2": "value2"
  },
  "training": {
    "dataset": "dataset_reference",
    "method": "training_method",
    "performance": "performance_metrics"
  },
  "state": {
    "current": "state_reference",
    "history": "state_history_reference"
  },
  "execution": {
    "environment": "execution_environment_requirements",
    "interface": "api_specification"
  }
}
```

## Integration with Storage

ERC-7857 is designed to work with any decentralized storage system that can provide:

1. **Persistent Storage**: For the encrypted metadata
2. **Secure Access Control**: To manage who can access the data
3. **Content Addressing**: To reference metadata by its hash
4. **Versioning**: To track metadata updates

While 0G Storage is optimized for INFT metadata storage, the standard can work with other storage solutions like IPFS, Arweave, or Filecoin.

## Compatibility Considerations

ERC-7857 is:
- Backwards compatible with ERC-721 interfaces
- Usable within existing NFT marketplaces
- Composable with other token standards
- Extendable for specific AI agent implementations

For detailed implementation specifications, please refer to the [official ERC-7857 specification](https://github.com/0glabs/0g-agent-nft/tree/eip-7857-draft).