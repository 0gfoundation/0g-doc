---
id: 0g-da-deep-dive
title: Technical Deep Dive
sidebar_position: 2
---
# 0G DA Technical Deep Dive

Модуль доступности данных (Data Availability, DA) позволяет пользователям отправлять фрагменты данных, называемые DA blob. Эти данные кодируются с избыточностью через прокси клиента и разделяются на несколько частей (срезов), которые затем отправляются на узлы DA. Узлы DA получают право проверять корректность срезов данных путем стейкинга. Каждый узел DA проверяет целостность и правильность своей части данных и подписывает её. После того как более 2/3 агрегированных подписей попадают в блокчейн, данные, связанные с соответствующим хэшем, считаются децентрализованно опубликованными.

Чтобы стимулировать узлы DA (Data Availability) хранить подписанные данные в течение определённого времени, сам процесс подписания не приносит вознаграждения. Вместо этого вознаграждения распределяются через процесс, называемый DA Sampling (выборка данных доступности). Во время каждого раунда DA Sampling любой срез данных (DA slice), находящийся в рамках определённого временного интервала, может участвовать в "лотерее" для получения вознаграждения. Узлы DA должны действительно хранить соответствующий срез данных, чтобы получить возможность участвовать в лотерее и претендовать на награду.

Процесс генерации узлов DA (Data Availability) аналогичен процессу PoS (Proof-of-Stake) базовой цепи и осуществляется через стейкинг. В течение каждой эпохи DA (приблизительно 8 часов) узлы DA распределяются по нескольким кворумам. Внутри каждого кворума узлам присваиваются номера от 0 до 3071. Каждое число закреплено ровно за одним узлом, однако один и тот же узел может быть назначен в несколько кворумов в зависимости от веса его стейкинга.

## DA Processing Flow

Модуль DA принимает входные данные длиной до 32 505 852 байтов и обрабатывает их следующим образом:

Дополнение и кодирование размера:

Данные дополняются нулями до объема 32 505 852 байтов.
В конец добавляется 4-байтовое число в формате little-endian, указывающее исходный размер входных данных.
Формирование матрицы:

Дополненные данные разбиваются на матрицу размером 1024 строки × 1024 столбца, последовательно заполняя строки по 31 байту в каждом элементе.
Каждая 31-байтовая ячейка дополняется еще одним байтом (нулём), чтобы стать 32-байтовой.
Избыточное кодирование:

Данные расширяются до матрицы размером 3072 строки × 1024 столбца с использованием методов избыточного кодирования.
Вычисляются erasure commitment (коммитмент стирания) и data root (корень данных) расширенной матрицы.
Отправка в DA контракт:

В DA контракт отправляются erasure commitment и data root, а также оплачивается комиссия.
DA контракт определяет эпоху, к которой принадлежат данные, и назначает кворум.
Распределение данных:

Erasure commitment, data root, каждая строка матрицы и доказательства корректности отправляются соответствующим узлам DA.
Агрегация подписей:

Более 2/3 узлов DA подписывают erasure commitment и data root.
Подписи агрегируются с использованием алгоритма подписи BLS и отправляются в DA контракт.
Эта последовательность обеспечивает надежное кодирование, хранение и проверку больших объемов данных в децентрализованной системе.
Детали кодирования стирания
После формирования матрицы каждый элемент преобразуется в 32-байтовую единицу данных, которую можно рассматривать как 32 байта данных или 256-битное число в формате little-endian. Обозначим элемент в $i$-й строке и $j$-м столбце как $c_{i,j}$.

Пусть конечное поле $\mathbb{F}$ является скалярным полем кривой BN254. Каждый элемент $c_{i,j}$ также рассматривается как целое число в конечном поле $\mathbb{F}$. Пусть $p$ — порядок $\mathbb{F}$, большое известное число, которое выражается как $2^{28} \times A + 1$, где $A$ — нечётное число. Число 3 является генератором мультипликативной группы $\mathbb{F}$. Определим $u = 3^{2^6 \times A}$ и $w = 3^{2^8 \times A}$, так что $w^{2^{20}} = 1$ и $u^4 = w$.

Теперь определим многочлен $f$ над $\mathbb{F} \rightarrow \mathbb{F}$ степени $d = 2^{20} - 1$, удовлетворяющий следующему:
Now we define a polynomial $f$ over $\mathbb{F}\rightarrow\mathbb{F}$ with degree $d=2^{20}-1$ satisfying

$$\forall\, 0\le i< 1024,\, 0\le j< 1024,\,f\left(w^{1024j+i}\right)=c_{i,j}$$

Then we extend the $1024\times1024$ matrix into $1024\times 3072$ matrix, where

$$\forall\, 1024\le i< 2048,\, 0\le j< 1024,\,c_{i,j}=f\left(u^2\cdot w^{1024j+(i-1024)}\right)$$

$$\forall\, 2048\le i< 3072,\, 0\le j< 1024,\,c_{i,j}=f\left(u\cdot w^{1024j+(i-2048)}\right)$$

Это расширение матрицы обеспечивает избыточность данных, необходимую для их восстановления в случае потерь.
Коммитмент стирания (erasure commitment) — это KZG-коммитмент многочлена $f$, который определяется как $f(\tau)\cdot G$, где $G$ — начальная точка на кривой BN254 G1, а $\tau$ — скрытый параметр, полученный в ходе церемонии доверенной установки perpetual powers of tau.(https://github.com/privacy-scaling-explorations/perpetualpowersoftau).
Корень данных (data root) определяется как корень входных данных, получаемый путём обработки элементов матрицы размером 1024 × 3072, где каждый элемент — это 32-байтовая единица, рассматриваемая как непрерывный ввод для хранения.

Конкретно, в соответствии с требованиями хранения, эти данные не требуют дополнения нулями. Они делятся на два массива секторов:

массив из 16 384 элементов;
массив из 8 192 элементов.
Эти массивы используются для создания структуры, обеспечивающей проверку и надёжность хранения данных.

Узлы DA должны проверить две части:

1. Согласованность между полученным фрагментом и корнем данных, в основном достигаемая с помощью доказательств Меркла.
2. Согласованность между полученным фрагментом и обязательством стирания, проверяется с помощью доказательств KZG. Здесь мы используем оптимизацию протокола AMT, представленную в [LVMT] (https://www.usenix.org/system/files/osdi23-li-chenxing.pdf), чтобы уменьшить накладные расходы на доказательство.

## Отбор проб DA

Блокчейн будет периодически выпускать задания DA Sampling на заданной высоте каждые `SAMPLE_PERIOD` блоков, а хэш родительского блока этих высот будет использоваться в качестве `SampleSeed` для DA Sampling.

### Список параметров

Постоянные параметры

|  Параметр          | Требование  | Значение по умолчанию   |
| ------------------ | ----------- | ----------------------- |
| MAX\_PODAS\_TARGET |             |    2^256 / 128 - 1      |

Параметры, настраиваемые администратором

| Параметр            | Требование  | Значение по умолчанию  | Код                                                                                                                                                                                                                                         |
| ------------------- | ----------- | ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| TARGET\_SUBMITS     |             | 20                     | [https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L296](https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L296) |
| EPOCH\_WINDOW\_SIZE |             | 300 (about 3 months)   | [https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L306](https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L306) |
| SAMPLE\_PERIOD      |             | 30 (about 1.5 minutes) | [https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L323](https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L323) |

### Ответы

В течение каждого периода каждый DA-слайс (одна строка) может быть разделен на 32 подстроки. Для каждой подстроки будет вычислено значение `podasQuality` с использованием `dataRoot` и присвоенных `epoch` и `quorumId` соответствующего DA-блоба.В течение каждого периода каждый DA-слайс (одна строка) может быть разделен на 32 подстроки. Для каждой подстроки будет вычислено значение `podasQuality` с использованием `dataRoot` и присвоенных `epoch` и `quorumId` соответствующего DA-блоба.

\<aside> 💡 По умолчанию все целые числа при вычислении хэш-значений имеют 256-битный формат big-endian. Единственным исключением является `lineIndex`, который имеет 64-битный формат big-endian.

Хеш-значение можно рассматривать как 32 байта данных или 256-битное целое число с большой последовательностью..

\</aside>

```python
lineQuality = keccak256(sampleSeed, epoch, quorumId, dataRoot, lineIndex);
dataQuality = keccak256(lineQuality, sublineIndex, data);
podasQuality = lineQuality + dataQuality
```

Если `podasQuality` меньше текущего `podasTarget` в контракте DA и `epoch` находится в пределах `[currentEpoch - EPOCH_WINDOW_SIZE, currentEpoch)`, то эта подстрока считается _**действительным ответом DAS**_ и имеет право на вознаграждение. Узел DA, назначенный на эту строку, может претендовать на вознаграждение.

В течение периода выборки может быть представлено и вознаграждено не более `TARGET_SUBMITS × 2` ответов DAS; любые представления, превышающие этот лимит, будут отклонены.

### Регулировка сложности

За период выборки ожидается получение `ЦЕЛЕВЫХ_СУБМИТОВ` действительных ответов. Если за период выборки будет получено больше или меньше ответов, значение `podasTarget` будет скорректировано следующим образом:

```python
podasTarget -= podasTarget * (actualSubmits - TARGET_SUBMITS) / TARGET_SUBMITS / 8
```

## Экономическая модель

### Список параметров

Параметры, настраиваемые администратором

| Параметр               | Требование  | Значение по умолчанию | Код                                                                                                                                                                                                                                         |
| ---------------------- | ----------- | --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| BASE\_REWARD           |             | 0                     | [https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L318](https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L318) |
| BLOB\_PRICE            |             | 0                     | [https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L331](https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L331) |
| SERVICE\_FEE\_RATE\_BP |             | 0                     | [https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L336](https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L336) |
| REWARD\_RATIO          | \[1]        | 1,200,000             | [https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L312](https://github.com/0glabs/0g-da-contract/blob/3951565fb6ad3096634da6493e9e863bb2846611/contracts/DAEntrance.sol#L312) |

\[1] `ЦЕЛЕВЫЕ_СУБМИТЫ` × Время, прошедшее за эпохи `EPOCH_WINDOW_SIZE` / Время, прошедшее за `SAMPLE_PERIOD` / `REWARD_RATIO` должно быть примерно от 0,5 до 2.

### Ценообразование

Когда пользователи отправляют метаданные для блоба DA, они должны заплатить взнос в размере `BLOB_PRICE`.

### Вознаграждение

Когда эпоха DA заканчивается, все вознаграждения из этой эпохи DA будут храниться в пуле вознаграждений DA. Каждый раз, когда отправляется правильный ответ, `1 / REWARD_RATIO` из пула вознаграждений будет распределяться между соответствующими узлами DA.

### Системные вознаграждения

На ранних этапах развития экосистемы фонд может зарезервировать часть токенов для системных вознаграждений. Когда DA-узел отправит правильный ответ, будет выдано дополнительное вознаграждение в размере `BASE_REWARD`.

Средства для базового вознаграждения будут вручную вноситься в контракт на вознаграждение и отслеживаться отдельно. Если баланс для базового вознаграждения недостаточен для покрытия одного базового вознаграждения, майнеры не смогут получить полное базовое вознаграждение.

### Сервисный сбор

Плата за обслуживание системы взимается как доля от платы за DA, уплаченной пользователем, в соответствии с параметром `SERVICE_FEE_RATE_BP`.

## Запустить узел

Инструкции по получению статуса подписчика DA и запуску собственного узла смотрите [здесь](../run-a-node/da-node.md).
